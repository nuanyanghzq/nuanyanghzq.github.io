<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为什么springboot项目不需要web.xml</title>
      <link href="/2019/11/18/webXml/"/>
      <url>/2019/11/18/webXml/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么springboot项目不需要web-xml"><a href="#为什么springboot项目不需要web-xml" class="headerlink" title="为什么springboot项目不需要web.xml"></a>为什么springboot项目不需要web.xml</h1><p>我们都知道以前一个项目的前端入口就是通过web.xml去配置的，然而这种springboot中我们根本没发现web.xml这是为什么呢？</p><h1 id="servlet3-0-新特性"><a href="#servlet3-0-新特性" class="headerlink" title="servlet3.0 新特性"></a>servlet3.0 新特性</h1><p>首先我们来看servlet3.0 新特性 servlet3.0 提供了若干新特性用于简化 Web 应用的开发和部署。<font color="#DC143C">其中一项新特性便是提供了无 xml 配置的特性。</font><br>servlet3.0 首先提供了 @WebServlet，@WebFilter 等注解，这样便有了抛弃 web.xml 的第一个途径，凭借注解声明 servlet 和 filter 来做到这一点。<br>Spring3.0奠定了SpringBoot自动装配的基础。3.0提供的java注解使得我们可以通过注解的方式来配置spring容器。省去了使用类似于spring-context.xml的配置文件。</p><h1 id="servlet4-0开始全面支持java8-0"><a href="#servlet4-0开始全面支持java8-0" class="headerlink" title="servlet4.0开始全面支持java8.0"></a>servlet4.0开始全面支持java8.0</h1><p>4.0 时代我们甚至连xml配置文件都不需要了完全使用java源码级别的配置与spring提供的注解就能快速的开发spring应用程序,但仍然无法改变Java Web应用程序的运行模式,我们仍然需要将war部署到Web Server 上，才能对外提供服务。</p><p><font color="#DC143C">再直白一点来说，存在web.xml的时候，Servlet容器会根据web.xml中的配置初始化我们的jar包（也可以说web.xml是我们的jar包和Servlet联系的中介）。而在Servlet3.0容器初始化时会调用jar包META-INF/services/javax.servlet.ServletContainerInitializer中指定的类的实现（javax.servlet.ServletContainerInitializer中的实现替代了web.xml的作用，而所谓的在@HandlesTypes注解中指定的感兴趣的类，可以理解为具体实现了web.xml的功能，当然也可以有其他的用途）。图片如下</font><br>ServletContainerInitializer这个类会在web容器启动阶段被回调，可以在onStartup方法里做一些servlet、filter、listener的注册等操作。<br>web容器启动后，调用所有WebApplicationInitializer的onStartup方法。<br>一般使用Springboot的时候，都会继承一个类SpringBootServletInitializer，在这个类的onStartup方法中，启动了整个Spring容器。</p><p><img alt data-src="https://img2018.cnblogs.com/blog/1635748/201905/1635748-20190528214050392-481345805.png" class="lazyload"></p><p>容器启动时将自动扫描类路径以查找实现Spring的webapplicationinitializer接口的所有实现，将其放进一个Set集合中 如下</p><p><img alt data-src="/img/springbootFile/Servlet.png" class="lazyload"></p><h1 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h1><p>为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制，当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services下以ServletContainerInitializer的全路径名称命名的文件，它的内容为ServletContainerInitializer实现类的全路径，将它们实例化</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么springboot项目不需要xml配置之springbootApplication</title>
      <link href="/2019/11/15/springbootApplication/"/>
      <url>/2019/11/15/springbootApplication/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>先看导入的依赖逐步分析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击进去发现他的父项目是 dependencies</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring‐boot‐dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>dependencies管理所有的依赖版本<br><img alt data-src="/img/springbootFile/springbootAppcotion.png" class="lazyload"><br>上面控制了各个版本 俗称:版本控制 以后导入pom依赖默认是不需要写版本号的（如果没有在dependencies里面还是需要版本号的）</p><h2 id="导入的依赖（由谁来导入jar包）"><a href="#导入的依赖（由谁来导入jar包）" class="headerlink" title="导入的依赖（由谁来导入jar包）"></a>导入的依赖（由谁来导入jar包）</h2><p>spring-boot-starter：spring-boot场景启动器<br>spring-boot-starter-：有很多的模块运行所依赖的组件<br>比如：<br>spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件；<br>spring-boot-starter-aop aop切面所需要的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），</span><br><span class="line">只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来。要用什</span><br><span class="line">么功能就导入什么场景的启动器</span><br></pre></td></tr></table></figure><h1 id="springboot为什么不需要xml配置了"><a href="#springboot为什么不需要xml配置了" class="headerlink" title="springboot为什么不需要xml配置了"></a><font color="#DC143C">springboot为什么不需要xml配置了</font></h1><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;           <span class="comment">// Spring应用启动起来         </span></span><br><span class="line">    SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;    </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot 就应该运行这个类的main方法来启动SpringBoot应用；</p><p>点进SpringBootApplication 我们会发现他是个组合配置类如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Inherited</span> </span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> </span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> </span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;       </span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),      </span></span><br><span class="line"><span class="class">    @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><h2 id="SpringBootConﬁguration"><a href="#SpringBootConﬁguration" class="headerlink" title="@SpringBootConﬁguration"></a>@SpringBootConﬁguration</h2><p>什么是配置类，以前我们在xml配置一些东西，在springboot上换成配置类来配置了<br>如下是SpringBootApplication 的配置类注解</p><p><strong>@SpringBootConﬁguration</strong>:Spring Boot的配置类；（标注在某个类上，表示这是一个Spring Boot的配置类）<br>点进<strong>@SpringBootConﬁguration</strong> 会发现注解<strong>@Conﬁguration</strong>注解<br><strong>@Conﬁguration</strong>是spring里面的原生 <strong>配置类</strong>注解  有这个注解表明这是一个配置类<br><strong>@SpringBootConﬁguration</strong> 是springboot的 <strong>配置类</strong>注解 有这个注解表明这是一个配置类</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>现在springboot把配置文件换成配置类不再需要xml复杂配置只需要加上这个注解 <strong>@SpringBootConﬁguration</strong><br><strong>@SpringBootConﬁguration</strong>的基础是 <strong>@Conﬁguration</strong>  如果再点进 <strong>@Conﬁguration</strong> 你会发现<br><strong>@Component</strong> 注解 表示容器的组件，由此可以发现配置类也是一个组件 </p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title=" @EnableAutoConfiguration"></a><font color="#DC143C"> <strong>@EnableAutoConfiguration</strong><font></font></font></h2><p><strong>SpringBootApplication</strong>里面还有 <strong>@EnableAutoConfiguration</strong><br><strong>@EnableAutoConfiguration</strong>：开启自动配置功能<br><strong>以前我们需要配置的东西（包扫描等），<font color="#DC143C">Spring Boot帮我们自动配置的一些东西，我们开启自动配置就好</font>；@EnableAutoConfiguration告诉SpringBoot开启自<br>动配置功能；这样自动配置才能生效；</strong></p><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a><strong>@AutoConfigurationPackage</strong></h2><p>点进 <strong>@EnableAutoConfiguration</strong>里面我们会看见下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><h2 id="AutoConfigurationPackage-1"><a href="#AutoConfigurationPackage-1" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>@AutoConfigurationPackage ：自动配置包<br>点进里面 会发现 @Import(AutoConﬁgurationPackages.Registrar.class)：<br><font color="#DC143C">@Import</font>是spring的底层注解<br>上面的意思是给容器中导入一个组件；导入的组件有AutoConfigurationPackages.Registrar.class</p><p>点击<font color="#DC143C">Registrar</font> 里面会看见下面的代码</p><p><img alt data-src="/img/springbootFile/Registrar.png" class="lazyload"><br><font color="#DC143C">将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器</font> </p><p><font color="#DC143C">注意上面只是扫描到sping容器里面并没有添加</font> </p><p>@EnableAutoConfiguration里面还有一个注解<font color="#DC143C"> @Import(EnableAutoConfigurationImportSelector.class)；</font><br>EnableAutoConfigurationImportSelector：导入哪些组件的选择器；<br>将所有需要导入的组件以数组全类名的方式返回；这些组件就会被<font color="#DC143C">添加</font>到容器中；<font color="#DC143C">(上面是扫描到sping容器，这里是添加)</font><br>比如我们做aop的功能，他已经把aop的功能组件给添加进去的我们就能直接用aop的功能<br>扫描到的组件如下<br><img alt data-src="/img/springbootFile/%E7%BB%84%E4%BB%B6.png" class="lazyload"><br>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作</p><p>以上就是为什么springboot不需要xml的原因</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开通博客的第一天</title>
      <link href="/2019/11/14/hello-world/"/>
      <url>/2019/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="开通博客的第一天"><a href="#开通博客的第一天" class="headerlink" title="开通博客的第一天"></a>开通博客的第一天</h2><blockquote><p>首先！ 感谢我师傅，帮我指导错误，帮我搭建这个博客 ，受到师傅的启发，搭建博客记录一些技术上的东西，俗话说：好记性不如烂笔头</p></blockquote><h3 id="以后更新的内容"><a href="#以后更新的内容" class="headerlink" title="以后更新的内容"></a>以后更新的内容</h3><blockquote><p>技术上以后会更新一些Java相关的技术，也会记录一些遇到的问题，做到自我反省，<br>先从基础的Java一些源码分析，慢慢的更新到框架，和微服务，数据库等…从小白做起,一步一个脚印</p></blockquote><h3 id="受到的启发"><a href="#受到的启发" class="headerlink" title="受到的启发"></a>受到的启发</h3><blockquote><p>因为天天看师傅，在更新博客也写的很详细，以后要像师傅靠齐，以前最早接触的博客大神是，纯洁的微笑<br>  他的博客也写的很好，所以想自己也创建一个</p></blockquote><h3 id="努力的放向"><a href="#努力的放向" class="headerlink" title="努力的放向"></a>努力的放向</h3><blockquote><p>以后会朝着师傅的脚印前进，心里面老想着，为什么和师傅同样是21岁，他已经月入过万了，我才是他一点零头，后面看<br>师傅技术，从后台写到前台，从单体项目写到聚合项目，现在在朝着微服务进发，各种vue shell  语法都会，是我见过最<br>厉害的了，一个人撑起一家公司，所以我学习的东西还有很多</p></blockquote><h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><blockquote><p>在我友链里面有我师傅的博客，他确实很强，可以看看文章，互相学习</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
